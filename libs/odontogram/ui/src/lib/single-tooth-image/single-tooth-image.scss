@use '../common-variables.scss' as common;
@use 'sass:list';
@use 'sass:map';
@use 'sass:math';

.tooth {
  // Center tooth number (text) and make it bold
  display: flex;
  flex: 0 1 auto;
  flex-direction: column;
  text-align: center;
  font-weight: 550;
  font-size: 1.15em;
  overflow: hidden;

  // Sets position relative to then place the colors
  // in the correct place
  position: relative;

  // Sets the offset of the cross and implant to be aligned with the root
  // It could further modified by tooth number so it could be more precise
  $crossOffset: 20%;
  $implantOffset: 27.5%;

  @for $i from 1 through 2 {
    @for $j from 1 through 8 {
      &.tooth-#{$i}#{$j} {
        .cross {
          &:after,
          &:before {
            top: $crossOffset;
          }
        }

        .implant {
          top: $implantOffset;
        }
      }
    }
  }

  @for $i from 3 through 4 {
    @for $j from 1 through 8 {
      &.tooth-#{$i}#{$j} {
        flex-direction: column-reverse;

        .cross {
          &:after,
          &:before {
            bottom: $crossOffset;
          }
        }

        .implant {
          bottom: $implantOffset;
        }
      }
    }
  }

  // Make images responsive
  img {
    width: 100%;
    height: auto;

    // Why is this needed ? I DONT FUCKING KNOW
    // but it makes the container a bit smaller and align correctly -.-
    vertical-align: middle;
  }

  .number {
    color: #fff;
    font-weight: 650;
  }

  // Adds a background color in the tooth number if the tooth has a treatment
  &.withTreatment .number {
    // background-color: #0275d8;
    background-color: #7a7a7a;
    color: #f2d45b;

    // En el componente de odontograma se quitan los bordes cuando se tocan entre ellos
    // Keep in mind that odontogram component alters the border style to remove borders if needed
    // by using ::ng-deep
    border-radius: 0.375em;
  }

  // Sets the color for pending status
  .status-pending {
    img,
    &.top,
    &.bottom,
    &.right,
    &.left,
    &.cross,
    &:after,
    &:before {
      background-color: common.$pendingColor !important;
    }

    &.implant {
      border-color: common.$pendingColor !important;
    }
  }

  .status-none {
    img,
    &.top,
    &.bottom,
    &.right,
    &.middle,
    &.left {
      background-color: #fff !important;
    }
  }

  // Sets the color for pending status
  .status-pending {
    img,
    &.top,
    &.bottom,
    &.right,
    &.left,
    &.middle,
    &.cross,
    &:after,
    &:before {
      background-color: common.$pendingColor !important;
    }

    &.implant {
      border-color: common.$pendingColor !important;
    }
  }

  // Sets the color for finished status
  .status-finished {
    img,
    &.top,
    &.bottom,
    &.right,
    &.left,
    &.middle,
    &.cross,
    &:after,
    &:before {
      background-color: common.$finishedColor !important;
    }

    &.implant {
      border-color: common.$finishedColor !important;
    }
  }

  .lateral {
    position: relative;
    // background-color: rgb(71, 151, 216);

    // Draws a X over the tooth root
    .cross {
      &:before,
      &:after {
        position: absolute;
        left: 47%;
        content: '';
        height: 50%;
        width: 3%;
      }

      &:before {
        transform: rotate(45deg);
      }

      &:after {
        transform: rotate(-45deg);
      }
    }

    // Two lines on the root to mark an implant
    .implant {
      content: '';
      left: 35%;
      position: absolute;
      background-color: transparent;
      width: 27.5%;
      height: 32.5%;
      border-left: 0.3em solid transparent;
      border-right: 0.3em solid transparent;
    }
  }

  .crown {
    $crownBorderStyle: dashed;
    $crownBorderColor: #fff;
    $crownBorderSize: 2;
    $crownBorderUnit: px;
    // Positions relative to then place the triangles absolutely
    position: relative;
    overflow: hidden;

    img {
      position: relative; // Position relative to make z-index work
      z-index: 2; // Increase z-index so the image is not covered by the triangles
    }

    // Makes a square of 50% of the container size
    // Positions it right in the middle and rotates it 45 degrees to make a diamond
    // Keeps rotating it 90 degrees for each position (top, right, bottom, left)
    // so that it is easier to apply borders since for example bottom border is always the left one
    // Having overflow: hidden, only half of the diamond (a triangle) is visible
    // Finally, adds a circle in the middle that is white by default
    // and changes color if it has a treatment

    $positions: (top, right, bottom, left);
    $positionToOffset: (
      top: left,
      right: top,
      bottom: left,
      left: top,
    );

    $len: list.length($positions);

    @for $index from 1 through $len {
      $pos: list.nth($positions, $index);
      $offsetPos: map.get($positionToOffset, $pos);

      .innerSquare.#{$pos} {
        position: absolute;

        $innerSquareSize: math.sqrt(2) * 50%;

        width: $innerSquareSize;
        height: $innerSquareSize;
        box-sizing: content-box;
        // rotate: -45, 45, 135, 225
        transform: rotate(-45deg + ($index - 1) * 90deg);

        // Center it along the perpendicular axis
        #{$offsetPos}: calc((100% - $innerSquareSize) / 2);

        // Offset it outward on its main axis
        #{$pos}: calc($innerSquareSize / -2);
      }

      .middle {
        position: absolute;

        width: 25%;
        height: 25%;
        left: 37.5%;
        top: 37.5%;
        border-radius: 50%;
        border-color: $crownBorderColor;
        border-style: $crownBorderStyle;
        border-width: $crownBorderSize + $crownBorderUnit;

        // Makes the circle smaller so that it fits better in smaller teeth
        &.smaller {
          width: 17.5%;
          height: 17.5%;
          left: 41.25%;
          top: 41.25%;
        }
      }

      $borderPositions: (bottom, left);

      // Default border if no treatment is assigned so that there is no gap between triangles
      @each $borderPos in $borderPositions {
        .innerSquare {
          border-#{$borderPos}-style: $crownBorderStyle;
          border-#{$borderPos}-width: $crownBorderSize + $crownBorderUnit;
          border-#{$borderPos}-color: $crownBorderColor;
        }

        // Add borders to the triangles if the zone has a treatment
        // By default it is invisible unless the next rule is applied
        // when its previous/next sibling also has a treatment
        .innerSquare.#{$pos}:not(#{common.$noStatusClass}) {
          border-#{$borderPos}-style: none;
          border-#{$borderPos}-width: $crownBorderSize + $crownBorderUnit;
          border-#{$borderPos}-color: $crownBorderColor;
        }
      }

      // Subtract 2 because SASS is index 1 based so we need to substract 1 to make it 0 based
      // and then another 1 to get the previous index of the list. By using modulo we make sure
      // the index is always between 0 and length-1. Then we add 1 to make it back to 1 based index
      $prevIndex: (($index - 2 + $len) % $len) + 1;
      // Now there is no need to substract because SASS is index 1 based so we are already starting at 1
      $nextIndex: (($index + $len) % $len) + 1;

      // define the two siblings with their order
      $siblingIndexes: ($prevIndex, $nextIndex);

      @for $s from 1 through length($siblingIndexes) {
        $siblingIndex: list.nth($siblingIndexes, $s);
        $sibling: list.nth($positions, $siblingIndex);

        &:has(.innerSquare.#{$pos}:not(#{common.$noStatusClass})):has(
            .innerSquare.#{$sibling}:not(#{common.$noStatusClass})
          ) {
          // current gets border at index $s
          .innerSquare.#{$pos} {
            border-#{list.nth($borderPositions, $s)}-style: $crownBorderStyle;
          }

          // sibling gets the other border, flip using modulo
          .innerSquare.#{$sibling} {
            border-#{list.nth($borderPositions, (($s % 2) + 1))}-style: $crownBorderStyle;
          }
        }
      }
    }
  }
}
